{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///webpack/bootstrap e3da162d3f6e28bbdbc8","webpack:///./public/js/vendor/primus.js","webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/main.js","webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/~/process/browser.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAA+C,2BAA2B;AAC1E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;2DC5FA;AACA;AACA;AACA;AACA,IAAG;AACH,6DAAiC,sBAAsB,EAAE;AACzD;AACA,EAAC;AACD;AACA,mCAAkC,gBAAgB,UAAU,UAAU,0CAA0C,8BAAwB,oBAAoB,8CAA8C,kCAAkC,YAAY,YAAY,mCAAmC,iBAAiB,gBAAgB,sBAAsB,oBAAoB,0CAA0C,YAAY,WAAW,YAAY,SAAS,GAAG;AAC3c;;AAEA;AACA;AACA;AACA,YAAW,aAAa;AACxB,YAAW,OAAO;AAClB,cAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B,yBAAyB;AACxD;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAU,iBAAiB;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA,6DAA4D,OAAO;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA,8DAA6D,OAAO;AACpE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,kEAAiE,OAAO;AACxE;AACA;;AAEA;AACA;AACA;AACA,gBAAe,MAAM;AACrB,gBAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,qEAAoE,OAAO;AAC3E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAAyC,SAAS;AAClD;AACA;;AAEA;AACA,IAAG;AACH;AACA;;AAEA,gBAAe,YAAY;AAC3B;;AAEA;AACA,4DAA2D;AAC3D,gEAA+D;AAC/D,oEAAmE;AACnE;AACA,2DAA0D,SAAS;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kEAAiE,YAAY;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,2BAA0B;AAC1B,uBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA6C;AAC7C,yBAAwB;AACxB,yBAAwB;AACxB,uBAAsB;AACtB,qBAAoB;;AAEpB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,0EAA0E;AAC7E;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,WAAU,OAAO;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAA+B,kBAAkB,EAAE;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAA+B,mBAAmB,EAAE;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAA+B,oBAAoB,EAAE;AACrD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,UAAU;AACrB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA8B,OAAO;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,gBAAgB;AACnB;AACA,EAAC,EAAE,QAAQ;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sBAAqB;AACrB,0BAAyB;AACzB,0BAAyB;AACzB,gDAA+C;AAC/C,qCAAoC;AACpC,4BAA2B;AAC3B,sCAAqC;AACrC,wBAAuB;AACvB,sBAAqB;AACrB,qBAAoB;AACpB,6BAA4B;AAC5B,wCAAuC;AACvC,0BAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA,oBAAmB;AACnB,oBAAmB;AACnB,oBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,aAAa;AAChC;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,YAAY;;AAEb;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA,6DAA4D,OAAO;AACnE;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,aAAY,YAAY;AACxB;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,aAAa;AACxB,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA,uBAAsB;AACtB;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA,6CAA4C,OAAO;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS,6BAA6B;AACtC;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,6BAA6B;AACnD;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK,YAAY,gCAAgC;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,UAAS,sBAAsB;AAC/B,gBAAe,mCAAmC;AAClD,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,QAAO,6BAA6B;AACpC,cAAa,SAAS;;AAEtB;AACA;AACA;AACA;;AAEA;;AAEA,QAAO,yBAAyB;AAChC,cAAa,SAAS;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,uFAAuF,EAAE,GAAG;AAC/F;AACA,EAAC;;;;;;;;ACh3ED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,iBAAiB;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,G;;;;;;;AC3EA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU","file":"vendor.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"realTimeReact\"] = factory();\n\telse\n\t\troot[\"realTimeReact\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonprealTimeReact\"];\n \twindow[\"webpackJsonprealTimeReact\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t1:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + {\"0\":\"99a214d94934e029ba27\"}[chunkId] + \".js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e3da162d3f6e28bbdbc8\n **/","(function UMDish(name, context, definition) {\n  context[name] = definition.call(context);\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = context[name];\n  } else if (typeof define === \"function\" && define.amd) {\n    define(function reference() { return context[name]; });\n  }\n})(\"Primus\", this, function wrapper() {\n  var define, module, exports\n    , Primus = (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\n/**\n * Create a function that will cleanup the instance.\n *\n * @param {Array|String} keys Properties on the instance that needs to be cleared.\n * @param {Object} options Additional configuration.\n * @returns {Function} Destroy function\n * @api public\n */\nmodule.exports = function demolish(keys, options) {\n  var split = /[, ]+/;\n\n  options = options ||  {};\n  keys = keys || [];\n\n  if ('string' === typeof keys) keys = keys.split(split);\n\n  /**\n   * Run addition cleanup hooks.\n   *\n   * @param {String} key Name of the clean up hook to run.\n   * @param {Mixed} selfie Reference to the instance we're cleaning up.\n   * @api private\n   */\n  function run(key, selfie) {\n    if (!options[key]) return;\n    if ('string' === typeof options[key]) options[key] = options[key].split(split);\n    if ('function' === typeof options[key]) return options[key].call(selfie);\n\n    for (var i = 0, type, what; i < options[key].length; i++) {\n      what = options[key][i];\n      type = typeof what;\n\n      if ('function' === type) {\n        what.call(selfie);\n      } else if ('string' === type && 'function' === typeof selfie[what]) {\n        selfie[what]();\n      }\n    }\n  }\n\n  /**\n   * Destroy the instance completely and clean up all the existing references.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n  return function destroy() {\n    var selfie = this\n      , i = 0\n      , prop;\n\n    if (selfie[keys[0]] === null) return false;\n    run('before', selfie);\n\n    for (; i < keys.length; i++) {\n      prop = keys[i];\n\n      if (selfie[prop]) {\n        if ('function' === typeof selfie[prop].destroy) selfie[prop].destroy();\n        selfie[prop] = null;\n      }\n    }\n\n    if (selfie.emit) selfie.emit('destroy');\n    run('after', selfie);\n\n    return true;\n  };\n};\n\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\n\n/**\n * Returns a function that when invoked executes all the listeners of the\n * given event with the given arguments.\n *\n * @returns {Function} The function that emits all the things.\n * @api public\n */\nmodule.exports = function emits() {\n  var self = this\n    , parser;\n\n  for (var i = 0, l = arguments.length, args = new Array(l); i < l; i++) {\n    args[i] = arguments[i];\n  }\n\n  //\n  // If the last argument is a function, assume that it's a parser.\n  //\n  if ('function' !== typeof args[args.length - 1]) return function emitter() {\n    for (var i = 0, l = arguments.length, arg = new Array(l); i < l; i++) {\n      arg[i] = arguments[i];\n    }\n\n    return self.emit.apply(self, args.concat(arg));\n  };\n\n  parser = args.pop();\n\n  /**\n   * The actual function that emits the given event. It returns a boolean\n   * indicating if the event was emitted.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n  return function emitter() {\n    for (var i = 0, l = arguments.length, arg = new Array(l + 1); i < l; i++) {\n      arg[i + 1] = arguments[i];\n    }\n\n    /**\n     * Async completion method for the parser.\n     *\n     * @param {Error} err Optional error when parsing failed.\n     * @param {Mixed} returned Emit instructions.\n     * @api private\n     */\n    arg[0] = function next(err, returned) {\n      if (err) return self.emit('error', err);\n\n      arg = returned === undefined\n        ? arg.slice(1) : returned === null\n          ? [] : returned;\n\n      self.emit.apply(self, args.concat(arg));\n    };\n\n    parser.apply(self, arg);\n    return true;\n  };\n};\n\n},{}],3:[function(_dereq_,module,exports){\n'use strict';\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  if (!this._events || !this._events[event]) return [];\n  if (this._events[event].fn) return [this._events[event].fn];\n\n  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n    ee[i] = this._events[event][i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  if (!this._events || !this._events[event]) return false;\n\n  var listeners = this._events[event]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n  if (!this._events || !this._events[event]) return this;\n\n  var listeners = this._events[event]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n      events.push(listeners);\n    }\n    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n        events.push(listeners[i]);\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[event] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[event];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[event];\n  else this._events = {};\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the module.\n//\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.EventEmitter2 = EventEmitter;\nEventEmitter.EventEmitter3 = EventEmitter;\n\n//\n// Expose the module.\n//\nmodule.exports = EventEmitter;\n\n},{}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=([^&]*)/g\n    , result = {}\n    , part;\n\n  //\n  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n  // the lastIndex property so we can continue executing this loop until we've\n  // parsed all results.\n  //\n  for (;\n    part = parser.exec(query);\n    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\n  );\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = [];\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n    }\n  }\n\n  return prefix + pairs.join('&');\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n\n},{}],5:[function(_dereq_,module,exports){\n'use strict';\n\nvar EventEmitter = _dereq_('eventemitter3')\n  , millisecond = _dereq_('millisecond')\n  , destroy = _dereq_('demolish')\n  , Tick = _dereq_('tick-tock')\n  , one = _dereq_('one-time');\n\n/**\n * Returns sane defaults about a given value.\n *\n * @param {String} name Name of property we want.\n * @param {Recovery} selfie Recovery instance that got created.\n * @param {Object} opts User supplied options we want to check.\n * @returns {Number} Some default value.\n * @api private\n */\nfunction defaults(name, selfie, opts) {\n  return millisecond(\n    name in opts ? opts[name] : (name in selfie ? selfie[name] : Recovery[name])\n  );\n}\n\n/**\n * Attempt to recover your connection with reconnection attempt.\n *\n * @constructor\n * @param {Object} options Configuration\n * @api public\n */\nfunction Recovery(options) {\n  var recovery = this;\n\n  if (!(recovery instanceof Recovery)) return new Recovery(options);\n\n  options = options || {};\n\n  recovery.attempt = null;        // Stores the current reconnect attempt.\n  recovery._fn = null;            // Stores the callback.\n\n  recovery['reconnect timeout'] = defaults('reconnect timeout', recovery, options);\n  recovery.retries = defaults('retries', recovery, options);\n  recovery.factor = defaults('factor', recovery, options);\n  recovery.max = defaults('max', recovery, options);\n  recovery.min = defaults('min', recovery, options);\n  recovery.timers = new Tick(recovery);\n}\n\nRecovery.prototype = new EventEmitter();\nRecovery.prototype.constructor = Recovery;\n\nRecovery['reconnect timeout'] = '30 seconds';  // Maximum time to wait for an answer.\nRecovery.max = Infinity;                       // Maximum delay.\nRecovery.min = '500 ms';                       // Minimum delay.\nRecovery.retries = 10;                         // Maximum amount of retries.\nRecovery.factor = 2;                           // Exponential back off factor.\n\n/**\n * Start a new reconnect procedure.\n *\n * @returns {Recovery}\n * @api public\n */\nRecovery.prototype.reconnect = function reconnect() {\n  var recovery = this;\n\n  return recovery.backoff(function backedoff(err, opts) {\n    opts.duration = (+new Date()) - opts.start;\n\n    if (err) return recovery.emit('reconnect failed', err, opts);\n\n    recovery.emit('reconnected', opts);\n  }, recovery.attempt);\n};\n\n/**\n * Exponential back off algorithm for retry operations. It uses a randomized\n * retry so we don't DDOS our server when it goes down under pressure.\n *\n * @param {Function} fn Callback to be called after the timeout.\n * @param {Object} opts Options for configuring the timeout.\n * @returns {Recovery}\n * @api private\n */\nRecovery.prototype.backoff = function backoff(fn, opts) {\n  var recovery = this;\n\n  opts = opts || recovery.attempt || {};\n\n  //\n  // Bailout when we already have a back off process running. We shouldn't call\n  // the callback then.\n  //\n  if (opts.backoff) return recovery;\n\n  opts['reconnect timeout'] = defaults('reconnect timeout', recovery, opts);\n  opts.retries = defaults('retries', recovery, opts);\n  opts.factor = defaults('factor', recovery, opts);\n  opts.max = defaults('max', recovery, opts);\n  opts.min = defaults('min', recovery, opts);\n\n  opts.start = +opts.start || +new Date();\n  opts.duration = +opts.duration || 0;\n  opts.attempt = +opts.attempt || 0;\n\n  //\n  // Bailout if we are about to make too much attempts.\n  //\n  if (opts.attempt === opts.retries) {\n    fn.call(recovery, new Error('Unable to recover'), opts);\n    return recovery;\n  }\n\n  //\n  // Prevent duplicate back off attempts using the same options object and\n  // increment our attempt as we're about to have another go at this thing.\n  //\n  opts.backoff = true;\n  opts.attempt++;\n\n  recovery.attempt = opts;\n\n  //\n  // Calculate the timeout, but make it randomly so we don't retry connections\n  // at the same interval and defeat the purpose. This exponential back off is\n  // based on the work of:\n  //\n  // http://dthain.blogspot.nl/2009/02/exponential-backoff-in-distributed.html\n  //\n  opts.scheduled = opts.attempt !== 1\n    ? Math.min(Math.round(\n        (Math.random() + 1) * opts.min * Math.pow(opts.factor, opts.attempt - 1)\n      ), opts.max)\n    : opts.min;\n\n  recovery.timers.setTimeout('reconnect', function delay() {\n    opts.duration = (+new Date()) - opts.start;\n    opts.backoff = false;\n    recovery.timers.clear('reconnect, timeout');\n\n    //\n    // Create a `one` function which can only be called once. So we can use the\n    // same function for different types of invocations to create a much better\n    // and usable API.\n    //\n    var connect = recovery._fn = one(function connect(err) {\n      recovery.reset();\n\n      if (err) return recovery.backoff(fn, opts);\n\n      fn.call(recovery, undefined, opts);\n    });\n\n    recovery.emit('reconnect', opts, connect);\n    recovery.timers.setTimeout('timeout', function timeout() {\n      var err = new Error('Failed to reconnect in a timely manner');\n      opts.duration = (+new Date()) - opts.start;\n\n      recovery.emit('reconnect timeout', err, opts);\n      connect(err);\n    }, opts['reconnect timeout']);\n  }, opts.scheduled);\n\n  //\n  // Emit a `reconnecting` event with current reconnect options. This allows\n  // them to update the UI and provide their users with feedback.\n  //\n  recovery.emit('reconnect scheduled', opts);\n\n  return recovery;\n};\n\n/**\n * Check if the reconnection process is currently reconnecting.\n *\n * @returns {Boolean}\n * @api public\n */\nRecovery.prototype.reconnecting = function reconnecting() {\n  return !!this.attempt;\n};\n\n/**\n * Tell our reconnection procedure that we're passed.\n *\n * @param {Error} err Reconnection failed.\n * @returns {Recovery}\n * @api public\n */\nRecovery.prototype.reconnected = function reconnected(err) {\n  if (this._fn) this._fn(err);\n  return this;\n};\n\n/**\n * Reset the reconnection attempt so it can be re-used again.\n *\n * @returns {Recovery}\n * @api public\n */\nRecovery.prototype.reset = function reset() {\n  this._fn = this.attempt = null;\n  this.timers.clear('reconnect, timeout');\n\n  return this;\n};\n\n/**\n * Clean up the instance.\n *\n * @type {Function}\n * @returns {Boolean}\n * @api public\n */\nRecovery.prototype.destroy = destroy('timers attempt _fn');\n\n//\n// Expose the module.\n//\nmodule.exports = Recovery;\n\n},{\"demolish\":1,\"eventemitter3\":3,\"millisecond\":6,\"one-time\":7,\"tick-tock\":8}],6:[function(_dereq_,module,exports){\n/**\n * Parse a time string and return the number value of it.\n *\n * @param {String} ms Time string.\n * @returns {Number}\n * @api private\n */\nmodule.exports = function millisecond(ms) {\n  'use strict';\n\n  if ('string' !== typeof ms || '0' === ms || +ms) return +ms;\n\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(ms)\n    , second = 1000\n    , minute = second * 60\n    , hour = minute * 60\n    , day = hour * 24\n    , amount;\n\n  if (!match) return 0;\n\n  amount = parseFloat(match[1]);\n\n  switch (match[2].toLowerCase()) {\n    case 'days':\n    case 'day':\n    case 'd':\n      return amount * day;\n\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return amount * hour;\n\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return amount * minute;\n\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return amount * second;\n\n    default:\n      return amount;\n  }\n};\n\n},{}],7:[function(_dereq_,module,exports){\n'use strict';\n\n/**\n * Wrap callbacks to prevent double execution.\n *\n * @param {Function} fn Function that should only be called once.\n * @returns {Function} A wrapped callback which prevents execution.\n * @api public\n */\nmodule.exports = function one(fn) {\n  var called = false\n    , value;\n\n  return function time() {\n    if (called) return value;\n\n    called = true;\n    value = fn.apply(this, arguments);\n    fn = null;\n\n    return value;\n  };\n};\n\n},{}],8:[function(_dereq_,module,exports){\n'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , ms = _dereq_('millisecond');\n\n/**\n * Simple timer management.\n *\n * @constructor\n * @param {Mixed} context Context of the callbacks that we execute.\n * @api public\n */\nfunction Tick(context) {\n  if (!(this instanceof Tick)) return new Tick(context);\n\n  this.timers = {};\n  this.context = context || this;\n}\n\n/**\n * Return a function which will just iterate over all assigned callbacks and\n * optionally clear the timers from memory if needed.\n *\n * @param {String} name Name of the timer we need to execute.\n * @param {Boolean} clear Also clear from memory.\n * @returns {Function}\n * @api private\n */\nTick.prototype.tock = function ticktock(name, clear) {\n  var tock = this;\n\n  return function tickedtock() {\n    if (!(name in tock.timers)) return;\n\n    var timer = tock.timers[name]\n      , fns = timer.fns.slice()\n      , l = fns.length\n      , i = 0;\n\n    if (clear) tock.clear(name);\n\n    for (; i < l; i++) {\n      fns[i].call(tock.context);\n    }\n  };\n};\n\n/**\n * Add a new timeout.\n *\n * @param {String} name Name of the timer.\n * @param {Function} fn Completion callback.\n * @param {Mixed} time Duration of the timer.\n * @returns {Tick}\n * @api public\n */\nTick.prototype.setTimeout = function timeout(name, fn, time) {\n  var tick = this;\n\n  if (tick.timers[name]) {\n    tick.timers[name].fns.push(fn);\n    return tick;\n  }\n\n  tick.timers[name] = {\n    timer: setTimeout(tick.tock(name, true), ms(time)),\n    clear: function clear(id) { clearTimeout(id); },\n    fns: [fn]\n  };\n\n  return tick;\n};\n\n/**\n * Add a new interval.\n *\n * @param {String} name Name of the timer.\n * @param {Function} fn Completion callback.\n * @param {Mixed} time Interval of the timer.\n * @returns {Tick}\n * @api public\n */\nTick.prototype.setInterval = function interval(name, fn, time) {\n  var tick = this;\n\n  if (tick.timers[name]) {\n    tick.timers[name].fns.push(fn);\n    return tick;\n  }\n\n  tick.timers[name] = {\n    timer: setInterval(tick.tock(name), ms(time)),\n    clear: function clear(id) { clearInterval(id); },\n    fns: [fn]\n  };\n\n  return tick;\n};\n\n/**\n * Add a new setImmediate.\n *\n * @param {String} name Name of the timer.\n * @param {Function} fn Completion callback.\n * @returns {Tick}\n * @api public\n */\nTick.prototype.setImmediate = function immediate(name, fn) {\n  var tick = this;\n\n  if ('function' !== typeof setImmediate) return tick.setTimeout(name, fn, 0);\n\n  if (tick.timers[name]) {\n    tick.timers[name].fns.push(fn);\n    return tick;\n  }\n\n  tick.timers[name] = {\n    timer: setImmediate(tick.tock(name, true)),\n    clear: function clear(id) { clearImmediate(id); },\n    fns: [fn]\n  };\n\n  return tick;\n};\n\n/**\n * Check if we have a timer set.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api public\n */\nTick.prototype.active = function active(name) {\n  return name in this.timers;\n};\n\n/**\n * Properly clean up all timeout references. If no arguments are supplied we\n * will attempt to clear every single timer that is present.\n *\n * @param {Arguments} ..args.. The names of the timeouts we need to clear\n * @returns {Tick}\n * @api public\n */\nTick.prototype.clear = function clear() {\n  var args = arguments.length ? arguments : []\n    , tick = this\n    , timer, i, l;\n\n  if (args.length === 1 && 'string' === typeof args[0]) {\n    args = args[0].split(/[, ]+/);\n  }\n\n  if (!args.length) {\n    for (timer in tick.timers) {\n      if (has.call(tick.timers, timer)) args.push(timer);\n    }\n  }\n\n  for (i = 0, l = args.length; i < l; i++) {\n    timer = tick.timers[args[i]];\n\n    if (!timer) continue;\n    timer.clear(timer.timer);\n\n    timer.fns = timer.timer = timer.clear = null;\n    delete tick.timers[args[i]];\n  }\n\n  return tick;\n};\n\n/**\n * We will no longer use this module, prepare your self for global cleanups.\n *\n * @returns {Boolean}\n * @api public\n */\nTick.prototype.end = Tick.prototype.destroy = function end() {\n  if (!this.context) return false;\n\n  this.clear();\n  this.context = this.timers = null;\n\n  return true;\n};\n\n/**\n * Adjust a timeout or interval to a new duration.\n *\n * @returns {Tick}\n * @api public\n */\nTick.prototype.adjust = function adjust(name, time) {\n  var interval\n    , tick = this\n    , timer = tick.timers[name];\n\n  if (!timer) return tick;\n\n  interval = timer.clear === clearInterval;\n  timer.clear(timer.timer);\n  timer.timer = (interval ? setInterval : setTimeout)(tick.tock(name, !interval), ms(time));\n\n  return tick;\n};\n\n//\n// Expose the timer factory.\n//\nmodule.exports = Tick;\n\n},{\"millisecond\":9}],9:[function(_dereq_,module,exports){\narguments[4][6][0].apply(exports,arguments)\n},{\"dup\":6}],10:[function(_dereq_,module,exports){\n/*globals require, define */\n'use strict';\n\nvar EventEmitter = _dereq_('eventemitter3')\n  , TickTock = _dereq_('tick-tock')\n  , Recovery = _dereq_('recovery')\n  , qs = _dereq_('querystringify')\n  , destroy = _dereq_('demolish');\n\n/**\n * Context assertion, ensure that some of our public Primus methods are called\n * with the correct context to ensure that\n *\n * @param {Primus} self The context of the function.\n * @param {String} method The method name.\n * @api private\n */\nfunction context(self, method) {\n  if (self instanceof Primus) return;\n\n  var failure = new Error('Primus#'+ method + '\\'s context should called with a Primus instance');\n\n  if ('function' !== typeof self.listeners || !self.listeners('error').length) {\n    throw failure;\n  }\n\n  self.emit('error', failure);\n}\n\n//\n// Sets the default connection URL, it uses the default origin of the browser\n// when supported but degrades for older browsers. In Node.js, we cannot guess\n// where the user wants to connect to, so we just default to localhost.\n//\nvar defaultUrl;\n\ntry {\n  if (location.origin) {\n    defaultUrl = location.origin;\n  } else {\n    defaultUrl = location.protocol +'//'+ location.hostname + (location.port ? ':'+ location.port : '');\n  }\n} catch (e) {\n  defaultUrl = 'http://127.0.0.1';\n}\n\n/**\n * Primus in a real-time library agnostic framework for establishing real-time\n * connections with servers.\n *\n * Options:\n * - reconnect, configuration for the reconnect process.\n * - manual, don't automatically call `.open` to start the connection.\n * - websockets, force the use of WebSockets, even when you should avoid them.\n * - timeout, connect timeout, server didn't respond in a timely manner.\n * - ping, The heartbeat interval for sending a ping packet to the server.\n * - pong, The heartbeat timeout for receiving a response to the ping.\n * - network, Use network events as leading method for network connection drops.\n * - strategy, Reconnection strategies.\n * - transport, Transport options.\n * - url, uri, The URL to use connect with the server.\n *\n * @constructor\n * @param {String} url The URL of your server.\n * @param {Object} options The configuration.\n * @api public\n */\nfunction Primus(url, options) {\n  if (!(this instanceof Primus)) return new Primus(url, options);\n  if ('function' !== typeof this.client) {\n    var message = 'The client library has not been compiled correctly, ' +\n      'see https://github.com/primus/primus#client-library for more details';\n    return this.critical(new Error(message));\n  }\n\n  if ('object' === typeof url) {\n    options = url;\n    url = options.url || options.uri || defaultUrl;\n  } else {\n    options = options || {};\n  }\n\n  var primus = this;\n\n  // The maximum number of messages that can be placed in queue.\n  options.queueSize = 'queueSize' in options ? options.queueSize : Infinity;\n\n  // Connection timeout duration.\n  options.timeout = 'timeout' in options ? options.timeout : 10e3;\n\n  // Stores the back off configuration.\n  options.reconnect = 'reconnect' in options ? options.reconnect : {};\n\n  // Heartbeat ping interval.\n  options.ping = 'ping' in options ? options.ping : 25000;\n\n  // Heartbeat pong response timeout.\n  options.pong = 'pong' in options ? options.pong : 10e3;\n\n  // Reconnect strategies.\n  options.strategy = 'strategy' in options ? options.strategy : [];\n\n  // Custom transport options.\n  options.transport = 'transport' in options ? options.transport : {};\n\n  primus.buffer = [];                           // Stores premature send data.\n  primus.writable = true;                       // Silly stream compatibility.\n  primus.readable = true;                       // Silly stream compatibility.\n  primus.url = primus.parse(url || defaultUrl); // Parse the URL to a readable format.\n  primus.readyState = Primus.CLOSED;            // The readyState of the connection.\n  primus.options = options;                     // Reference to the supplied options.\n  primus.timers = new TickTock(this);           // Contains all our timers.\n  primus.socket = null;                         // Reference to the internal connection.\n  primus.latency = 0;                           // Latency between messages.\n  primus.stamps = 0;                            // Counter to make timestamps unique.\n  primus.disconnect = false;                    // Did we receive a disconnect packet?\n  primus.transport = options.transport;         // Transport options.\n  primus.transformers = {                       // Message transformers.\n    outgoing: [],\n    incoming: []\n  };\n\n  //\n  // Create our reconnection instance.\n  //\n  primus.recovery = new Recovery(options.reconnect);\n\n  //\n  // Parse the reconnection strategy. It can have the following strategies:\n  //\n  // - timeout: Reconnect when we have a network timeout.\n  // - disconnect: Reconnect when we have an unexpected disconnect.\n  // - online: Reconnect when we're back online.\n  //\n  if ('string' === typeof options.strategy) {\n    options.strategy = options.strategy.split(/\\s?\\,\\s?/g);\n  }\n\n  if (false === options.strategy) {\n    //\n    // Strategies are disabled, but we still need an empty array to join it in\n    // to nothing.\n    //\n    options.strategy = [];\n  } else if (!options.strategy.length) {\n    options.strategy.push('disconnect', 'online');\n\n    //\n    // Timeout based reconnection should only be enabled conditionally. When\n    // authorization is enabled it could trigger.\n    //\n    if (!this.authorization) options.strategy.push('timeout');\n  }\n\n  options.strategy = options.strategy.join(',').toLowerCase();\n\n  //\n  // Force the use of WebSockets, even when we've detected some potential\n  // broken WebSocket implementation.\n  //\n  if ('websockets' in options) {\n    primus.AVOID_WEBSOCKETS = !options.websockets;\n  }\n\n  //\n  // Force or disable the use of NETWORK events as leading client side\n  // disconnection detection.\n  //\n  if ('network' in options) {\n    primus.NETWORK_EVENTS = options.network;\n  }\n\n  //\n  // Check if the user wants to manually initialise a connection. If they don't,\n  // we want to do it after a really small timeout so we give the users enough\n  // time to listen for `error` events etc.\n  //\n  if (!options.manual) primus.timers.setTimeout('open', function open() {\n    primus.timers.clear('open');\n    primus.open();\n  }, 0);\n\n  primus.initialise(options);\n}\n\n/**\n * Simple require wrapper to make browserify, node and require.js play nice.\n *\n * @param {String} name The module to require.\n * @returns {Object|Undefined} The module that we required.\n * @api private\n */\nPrimus.require = function requires(name) {\n  if ('function' !== typeof _dereq_) return undefined;\n\n  return !('function' === typeof define && define.amd)\n    ? _dereq_(name)\n    : undefined;\n};\n\n//\n// It's possible that we're running in Node.js or in a Node.js compatible\n// environment such as browserify. In these cases we want to use some build in\n// libraries to minimize our dependence on the DOM.\n//\nvar Stream, parse;\n\ntry {\n  Primus.Stream = Stream = Primus.require('stream');\n  parse = Primus.require('url').parse;\n\n  //\n  // Normally inheritance is done in the same way as we do in our catch\n  // statement. But due to changes to the EventEmitter interface in Node 0.10\n  // this will trigger annoying memory leak warnings and other potential issues\n  // outlined in the issue linked below.\n  //\n  // @see https://github.com/joyent/node/issues/4971\n  //\n  Primus.require('util').inherits(Primus, Stream);\n} catch (e) {\n  Primus.Stream = EventEmitter;\n  Primus.prototype = new EventEmitter();\n\n  //\n  // In the browsers we can leverage the DOM to parse the URL for us. It will\n  // automatically default to host of the current server when we supply it path\n  // etc.\n  //\n  parse = function parse(url) {\n    var a = document.createElement('a')\n      , data = {}\n      , key;\n\n    a.href = url;\n\n    //\n    // Transform it from a readOnly object to a read/writable object so we can\n    // change some parsed values. This is required if we ever want to override\n    // a port number etc. (as browsers remove port 443 and 80 from the URL's).\n    //\n    for (key in a) {\n      if ('string' === typeof a[key] || 'number' === typeof a[key]) {\n        data[key] = a[key];\n      }\n    }\n\n    //\n    // We need to make sure that the URL is properly encoded because IE doesn't\n    // do this automatically.\n    //\n    data.href = encodeURI(decodeURI(data.href));\n\n    //\n    // If we don't obtain a port number (e.g. when using zombie) then try\n    // and guess at a value from the 'href' value.\n    //\n    if (!data.port) {\n      var splits = (data.href || '').split('/');\n      if (splits.length > 2) {\n        var host = splits[2]\n          , atSignIndex = host.lastIndexOf('@');\n\n        if (~atSignIndex) host = host.slice(atSignIndex + 1);\n\n        splits = host.split(':');\n        if (splits.length === 2) data.port = splits[1];\n      }\n    }\n\n    //\n    // IE quirk: The `protocol` is parsed as \":\" or \"\" when a protocol agnostic\n    // URL is used. In this case we extract the value from the `href` value.\n    //\n    if (!data.protocol || ':' === data.protocol) {\n      data.protocol = data.href.substr(0, data.href.indexOf(':') + 1);\n    }\n\n    //\n    // Safari 5.1.7 (windows) quirk: When parsing a URL without a port number\n    // the `port` in the data object will default to \"0\" instead of the expected\n    // \"\". We're going to do an explicit check on \"0\" and force it to \"\".\n    //\n    if ('0' === data.port) data.port = '';\n\n    //\n    // Browsers do not parse authorization information, so we need to extract\n    // that from the URL.\n    //\n    if (~data.href.indexOf('@') && !data.auth) {\n      var start = data.protocol.length + 2;\n      data.auth = data.href.slice(start, data.href.indexOf(data.pathname, start)).split('@')[0];\n    }\n\n    return data;\n  };\n}\n\n/**\n * Primus readyStates, used internally to set the correct ready state.\n *\n * @type {Number}\n * @private\n */\nPrimus.OPENING = 1;   // We're opening the connection.\nPrimus.CLOSED  = 2;   // No active connection.\nPrimus.OPEN    = 3;   // The connection is open.\n\n/**\n * Are we working with a potentially broken WebSockets implementation? This\n * boolean can be used by transformers to remove `WebSockets` from their\n * supported transports.\n *\n * @type {Boolean}\n * @private\n */\nPrimus.prototype.AVOID_WEBSOCKETS = false;\n\n/**\n * Some browsers support registering emitting `online` and `offline` events when\n * the connection has been dropped on the client. We're going to detect it in\n * a simple `try {} catch (e) {}` statement so we don't have to do complicated\n * feature detection.\n *\n * @type {Boolean}\n * @private\n */\nPrimus.prototype.NETWORK_EVENTS = false;\nPrimus.prototype.online = true;\n\ntry {\n  if (\n       Primus.prototype.NETWORK_EVENTS = 'onLine' in navigator\n    && (window.addEventListener || document.body.attachEvent)\n  ) {\n    if (!navigator.onLine) {\n      Primus.prototype.online = false;\n    }\n  }\n} catch (e) { }\n\n/**\n * The Ark contains all our plugins definitions. It's namespaced by\n * name => plugin.\n *\n * @type {Object}\n * @private\n */\nPrimus.prototype.ark = {};\n\n/**\n * Simple emit wrapper that returns a function that emits an event once it's\n * called. This makes it easier for transports to emit specific events.\n *\n * @returns {Function} A function that will emit the event when called.\n * @api public\n */\nPrimus.prototype.emits = _dereq_('emits');\n\n/**\n * A small wrapper around `emits` to add a default parser when one is not\n * supplied. The default parser will defer the emission of the event to make\n * sure that the event is emitted at the correct time.\n *\n * @returns {Function} A function that will emit the event when called.\n * @api private\n */\nPrimus.prototype.trigger = function trigger() {\n  for (var i = 0, l = arguments.length, args = new Array(l); i < l; i++) {\n    args[i] = arguments[i];\n  }\n\n  if ('function' !== typeof args[l - 1]) args.push(function defer(next) {\n    setTimeout(next, 0);\n  });\n\n  return this.emits.apply(this, args);\n};\n\n/**\n * Return the given plugin.\n *\n * @param {String} name The name of the plugin.\n * @returns {Object|undefined} The plugin or undefined.\n * @api public\n */\nPrimus.prototype.plugin = function plugin(name) {\n  context(this, 'plugin');\n\n  if (name) return this.ark[name];\n\n  var plugins = {};\n\n  for (name in this.ark) {\n    plugins[name] = this.ark[name];\n  }\n\n  return plugins;\n};\n\n/**\n * Checks if the given event is an emitted event by Primus.\n *\n * @param {String} evt The event name.\n * @returns {Boolean} Indication of the event is reserved for internal use.\n * @api public\n */\nPrimus.prototype.reserved = function reserved(evt) {\n  return (/^(incoming|outgoing)::/).test(evt)\n  || evt in this.reserved.events;\n};\n\n/**\n * The actual events that are used by the client.\n *\n * @type {Object}\n * @public\n */\nPrimus.prototype.reserved.events = {\n  'reconnect scheduled': 1,\n  'reconnect timeout': 1,\n  'readyStateChange': 1,\n  'reconnect failed': 1,\n  'reconnected': 1,\n  'reconnect': 1,\n  'offline': 1,\n  'timeout': 1,\n  'online': 1,\n  'error': 1,\n  'close': 1,\n  'open': 1,\n  'data': 1,\n  'end': 1\n};\n\n/**\n * Initialise the Primus and setup all parsers and internal listeners.\n *\n * @param {Object} options The original options object.\n * @returns {Primus}\n * @api private\n */\nPrimus.prototype.initialise = function initialise(options) {\n  var primus = this\n    , start;\n\n  primus.recovery\n  .on('reconnected', primus.emits('reconnected'))\n  .on('reconnect failed', primus.emits('reconnect failed', function failed(data) {\n    primus.emit('end');\n    return data;\n  }))\n  .on('reconnect timeout', primus.emits('reconnect timeout'))\n  .on('reconnect scheduled', primus.emits('reconnect scheduled'))\n  .on('reconnect', primus.emits('reconnect', function reconnect(next) {\n    primus.emit('outgoing::reconnect');\n    next();\n  }));\n\n  primus.on('outgoing::open', function opening() {\n    var readyState = primus.readyState;\n\n    primus.readyState = Primus.OPENING;\n    if (readyState !== primus.readyState) {\n      primus.emit('readyStateChange', 'opening');\n    }\n\n    start = +new Date();\n  });\n\n  primus.on('incoming::open', function opened() {\n    var readyState = primus.readyState;\n\n    if (primus.recovery.reconnecting()) {\n      primus.recovery.reconnected();\n    }\n\n    //\n    // The connection has been opened so we should set our state to\n    // (writ|read)able so our stream compatibility works as intended.\n    //\n    primus.writable = true;\n    primus.readable = true;\n\n    //\n    // Make sure we are flagged as `online` as we've successfully opened the\n    // connection.\n    //\n    if (!primus.online) {\n      primus.online = true;\n      primus.emit('online');\n    }\n\n    primus.readyState = Primus.OPEN;\n    if (readyState !== primus.readyState) {\n      primus.emit('readyStateChange', 'open');\n    }\n\n    primus.latency = +new Date() - start;\n    primus.timers.clear('ping', 'pong');\n    primus.heartbeat();\n\n    if (primus.buffer.length) {\n      var data = primus.buffer.slice()\n        , length = data.length\n        , i = 0;\n\n      primus.buffer.length = 0;\n\n      for (; i < length; i++) {\n        primus._write(data[i]);\n      }\n    }\n\n    primus.emit('open');\n  });\n\n  primus.on('incoming::pong', function pong(time) {\n    primus.online = true;\n    primus.timers.clear('pong');\n    primus.heartbeat();\n\n    primus.latency = (+new Date()) - time;\n  });\n\n  primus.on('incoming::error', function error(e) {\n    var connect = primus.timers.active('connect')\n      , err = e;\n\n    //\n    // When the error is not an Error instance we try to normalize it.\n    //\n    if ('string' === typeof e) {\n      err = new Error(e);\n    } else if (!(e instanceof Error) && 'object' === typeof e) {\n      //\n      // BrowserChannel and SockJS returns an object which contains some\n      // details of the error. In order to have a proper error we \"copy\" the\n      // details in an Error instance.\n      //\n      err = new Error(e.message || e.reason);\n      for (var key in e) {\n        if (Object.prototype.hasOwnProperty.call(e, key))\n          err[key] = e[key];\n      }\n    }\n    //\n    // We're still doing a reconnect attempt, it could be that we failed to\n    // connect because the server was down. Failing connect attempts should\n    // always emit an `error` event instead of a `open` event.\n    //\n    //\n    if (primus.recovery.reconnecting()) return primus.recovery.reconnected(err);\n    if (primus.listeners('error').length) primus.emit('error', err);\n\n    //\n    // We received an error while connecting, this most likely the result of an\n    // unauthorized access to the server.\n    //\n    if (connect) {\n      if (~primus.options.strategy.indexOf('timeout')) {\n        primus.recovery.reconnect();\n      } else {\n        primus.end();\n      }\n    }\n  });\n\n  primus.on('incoming::data', function message(raw) {\n    primus.decoder(raw, function decoding(err, data) {\n      //\n      // Do a \"save\" emit('error') when we fail to parse a message. We don't\n      // want to throw here as listening to errors should be optional.\n      //\n      if (err) return primus.listeners('error').length && primus.emit('error', err);\n\n      //\n      // Handle all \"primus::\" prefixed protocol messages.\n      //\n      if (primus.protocol(data)) return;\n      primus.transforms(primus, primus, 'incoming', data, raw);\n    });\n  });\n\n  primus.on('incoming::end', function end() {\n    var readyState = primus.readyState;\n\n    //\n    // This `end` started with the receiving of a primus::server::close packet\n    // which indicated that the user/developer on the server closed the\n    // connection and it was not a result of a network disruption. So we should\n    // kill the connection without doing a reconnect.\n    //\n    if (primus.disconnect) {\n      primus.disconnect = false;\n\n      return primus.end();\n    }\n\n    //\n    // Always set the readyState to closed, and if we're still connecting, close\n    // the connection so we're sure that everything after this if statement block\n    // is only executed because our readyState is set to `open`.\n    //\n    primus.readyState = Primus.CLOSED;\n    if (readyState !== primus.readyState) {\n      primus.emit('readyStateChange', 'end');\n    }\n\n    if (primus.timers.active('connect')) primus.end();\n    if (readyState !== Primus.OPEN) {\n      return primus.recovery.reconnecting()\n        ? primus.recovery.reconnect()\n        : false;\n    }\n\n    this.writable = false;\n    this.readable = false;\n\n    //\n    // Clear all timers in case we're not going to reconnect.\n    //\n    this.timers.clear();\n\n    //\n    // Fire the `close` event as an indication of connection disruption.\n    // This is also fired by `primus#end` so it is emitted in all cases.\n    //\n    primus.emit('close');\n\n    //\n    // The disconnect was unintentional, probably because the server has\n    // shutdown, so if the reconnection is enabled start a reconnect procedure.\n    //\n    if (~primus.options.strategy.indexOf('disconnect')) {\n      return primus.recovery.reconnect();\n    }\n\n    primus.emit('outgoing::end');\n    primus.emit('end');\n  });\n\n  //\n  // Setup the real-time client.\n  //\n  primus.client();\n\n  //\n  // Process the potential plugins.\n  //\n  for (var plugin in primus.ark) {\n    primus.ark[plugin].call(primus, primus, options);\n  }\n\n  //\n  // NOTE: The following code is only required if we're supporting network\n  // events as it requires access to browser globals.\n  //\n  if (!primus.NETWORK_EVENTS) return primus;\n\n  /**\n   * Handler for offline notifications.\n   *\n   * @api private\n   */\n  function offline() {\n    if (!primus.online) return; // Already or still offline, bailout.\n\n    primus.online = false;\n    primus.emit('offline');\n    primus.end();\n\n    //\n    // It is certainly possible that we're in a reconnection loop and that the\n    // user goes offline. In this case we want to kill the existing attempt so\n    // when the user goes online, it will attempt to reconnect freshly again.\n    //\n    primus.recovery.reset();\n  }\n\n  /**\n   * Handler for online notifications.\n   *\n   * @api private\n   */\n  function online() {\n    if (primus.online) return; // Already or still online, bailout.\n\n    primus.online = true;\n    primus.emit('online');\n\n    if (~primus.options.strategy.indexOf('online')) {\n      primus.recovery.reconnect();\n    }\n  }\n\n  if (window.addEventListener) {\n    window.addEventListener('offline', offline, false);\n    window.addEventListener('online', online, false);\n  } else if (document.body.attachEvent){\n    document.body.attachEvent('onoffline', offline);\n    document.body.attachEvent('ononline', online);\n  }\n\n  return primus;\n};\n\n/**\n * Really dead simple protocol parser. We simply assume that every message that\n * is prefixed with `primus::` could be used as some sort of protocol definition\n * for Primus.\n *\n * @param {String} msg The data.\n * @returns {Boolean} Is a protocol message.\n * @api private\n */\nPrimus.prototype.protocol = function protocol(msg) {\n  if (\n       'string' !== typeof msg\n    || msg.indexOf('primus::') !== 0\n  ) return false;\n\n  var last = msg.indexOf(':', 8)\n    , value = msg.slice(last + 2);\n\n  switch (msg.slice(8,  last)) {\n    case 'pong':\n      this.emit('incoming::pong', value);\n    break;\n\n    case 'server':\n      //\n      // The server is closing the connection, forcefully disconnect so we don't\n      // reconnect again.\n      //\n      if ('close' === value) {\n        this.disconnect = true;\n      }\n    break;\n\n    case 'id':\n      this.emit('incoming::id', value);\n    break;\n\n    //\n    // Unknown protocol, somebody is probably sending `primus::` prefixed\n    // messages.\n    //\n    default:\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Execute the set of message transformers from Primus on the incoming or\n * outgoing message.\n * This function and it's content should be in sync with Spark#transforms in\n * spark.js.\n *\n * @param {Primus} primus Reference to the Primus instance with message transformers.\n * @param {Spark|Primus} connection Connection that receives or sends data.\n * @param {String} type The type of message, 'incoming' or 'outgoing'.\n * @param {Mixed} data The data to send or that has been received.\n * @param {String} raw The raw encoded data.\n * @returns {Primus}\n * @api public\n */\nPrimus.prototype.transforms = function transforms(primus, connection, type, data, raw) {\n  var packet = { data: data }\n    , fns = primus.transformers[type];\n\n  //\n  // Iterate in series over the message transformers so we can allow optional\n  // asynchronous execution of message transformers which could for example\n  // retrieve additional data from the server, do extra decoding or even\n  // message validation.\n  //\n  (function transform(index, done) {\n    var transformer = fns[index++];\n\n    if (!transformer) return done();\n\n    if (1 === transformer.length) {\n      if (false === transformer.call(connection, packet)) {\n        //\n        // When false is returned by an incoming transformer it means that's\n        // being handled by the transformer and we should not emit the `data`\n        // event.\n        //\n        return;\n      }\n\n      return transform(index, done);\n    }\n\n    transformer.call(connection, packet, function finished(err, arg) {\n      if (err) return connection.emit('error', err);\n      if (false === arg) return;\n\n      transform(index, done);\n    });\n  }(0, function done() {\n    //\n    // We always emit 2 arguments for the data event, the first argument is the\n    // parsed data and the second argument is the raw string that we received.\n    // This allows you, for example, to do some validation on the parsed data\n    // and then save the raw string in your database without the stringify\n    // overhead.\n    //\n    if ('incoming' === type) return connection.emit('data', packet.data, raw);\n\n    connection._write(packet.data);\n  }));\n\n  return this;\n};\n\n/**\n * Retrieve the current id from the server.\n *\n * @param {Function} fn Callback function.\n * @returns {Primus}\n * @api public\n */\nPrimus.prototype.id = function id(fn) {\n  if (this.socket && this.socket.id) return fn(this.socket.id);\n\n  this._write('primus::id::');\n  return this.once('incoming::id', fn);\n};\n\n/**\n * Establish a connection with the server. When this function is called we\n * assume that we don't have any open connections. If you do call it when you\n * have a connection open, it could cause duplicate connections.\n *\n * @returns {Primus}\n * @api public\n */\nPrimus.prototype.open = function open() {\n  context(this, 'open');\n\n  //\n  // Only start a `connection timeout` procedure if we're not reconnecting as\n  // that shouldn't count as an initial connection. This should be started\n  // before the connection is opened to capture failing connections and kill the\n  // timeout.\n  //\n  if (!this.recovery.reconnecting() && this.options.timeout) this.timeout();\n\n  this.emit('outgoing::open');\n  return this;\n};\n\n/**\n * Send a new message.\n *\n * @param {Mixed} data The data that needs to be written.\n * @returns {Boolean} Always returns true as we don't support back pressure.\n * @api public\n */\nPrimus.prototype.write = function write(data) {\n  context(this, 'write');\n  this.transforms(this, this, 'outgoing', data);\n\n  return true;\n};\n\n/**\n * The actual message writer.\n *\n * @param {Mixed} data The message that needs to be written.\n * @returns {Boolean} Successful write to the underlaying transport.\n * @api private\n */\nPrimus.prototype._write = function write(data) {\n  var primus = this;\n\n  //\n  // The connection is closed, normally this would already be done in the\n  // `spark.write` method, but as `_write` is used internally, we should also\n  // add the same check here to prevent potential crashes by writing to a dead\n  // socket.\n  //\n  if (Primus.OPEN !== primus.readyState) {\n    //\n    // If the buffer is at capacity, remove the first item.\n    //\n    if (this.buffer.length === this.options.queueSize) {\n      this.buffer.splice(0, 1);\n    }\n\n    this.buffer.push(data);\n    return false;\n  }\n\n  primus.encoder(data, function encoded(err, packet) {\n    //\n    // Do a \"save\" emit('error') when we fail to parse a message. We don't\n    // want to throw here as listening to errors should be optional.\n    //\n    if (err) return primus.listeners('error').length && primus.emit('error', err);\n    primus.emit('outgoing::data', packet);\n  });\n\n  return true;\n};\n\n/**\n * Send a new heartbeat over the connection to ensure that we're still\n * connected and our internet connection didn't drop. We cannot use server side\n * heartbeats for this unfortunately.\n *\n * @returns {Primus}\n * @api private\n */\nPrimus.prototype.heartbeat = function heartbeat() {\n  var primus = this;\n\n  if (!primus.options.ping) return primus;\n\n  /**\n   * Exterminate the connection as we've timed out.\n   *\n   * @api private\n   */\n  function pong() {\n    primus.timers.clear('pong');\n\n    //\n    // The network events already captured the offline event.\n    //\n    if (!primus.online) return;\n\n    primus.online = false;\n    primus.emit('offline');\n    primus.emit('incoming::end');\n  }\n\n  /**\n   * We should send a ping message to the server.\n   *\n   * @api private\n   */\n  function ping() {\n    var value = +new Date();\n\n    primus.timers.clear('ping');\n    primus._write('primus::ping::'+ value);\n    primus.emit('outgoing::ping', value);\n    primus.timers.setTimeout('pong', pong, primus.options.pong);\n  }\n\n  primus.timers.setTimeout('ping', ping, primus.options.ping);\n  return this;\n};\n\n/**\n * Start a connection timeout.\n *\n * @returns {Primus}\n * @api private\n */\nPrimus.prototype.timeout = function timeout() {\n  var primus = this;\n\n  /**\n   * Remove all references to the timeout listener as we've received an event\n   * that can be used to determine state.\n   *\n   * @api private\n   */\n  function remove() {\n    primus.removeListener('error', remove)\n          .removeListener('open', remove)\n          .removeListener('end', remove)\n          .timers.clear('connect');\n  }\n\n  primus.timers.setTimeout('connect', function expired() {\n    remove(); // Clean up old references.\n\n    if (primus.readyState === Primus.OPEN || primus.recovery.reconnecting()) {\n      return;\n    }\n\n    primus.emit('timeout');\n\n    //\n    // We failed to connect to the server.\n    //\n    if (~primus.options.strategy.indexOf('timeout')) {\n      primus.recovery.reconnect();\n    } else {\n      primus.end();\n    }\n  }, primus.options.timeout);\n\n  return primus.on('error', remove)\n    .on('open', remove)\n    .on('end', remove);\n};\n\n/**\n * Close the connection completely.\n *\n * @param {Mixed} data last packet of data.\n * @returns {Primus}\n * @api public\n */\nPrimus.prototype.end = function end(data) {\n  context(this, 'end');\n\n  if (this.readyState === Primus.CLOSED && !this.timers.active('connect')) {\n    //\n    // If we are reconnecting stop the reconnection procedure.\n    //\n    if (this.recovery.reconnecting()) {\n      this.recovery.reset();\n      this.emit('end');\n    }\n\n    return this;\n  }\n\n  if (data !== undefined) this.write(data);\n\n  this.writable = false;\n  this.readable = false;\n\n  var readyState = this.readyState;\n  this.readyState = Primus.CLOSED;\n\n  if (readyState !== this.readyState) {\n    this.emit('readyStateChange', 'end');\n  }\n\n  this.timers.clear();\n  this.emit('outgoing::end');\n  this.emit('close');\n  this.emit('end');\n\n  return this;\n};\n\n/**\n * Completely demolish the Primus instance and forcefully nuke all references.\n *\n * @returns {Boolean}\n * @api public\n */\nPrimus.prototype.destroy = destroy('url timers options recovery socket transport transformers', {\n  before: 'end',\n  after: 'removeAllListeners'\n});\n\n/**\n * Create a shallow clone of a given object.\n *\n * @param {Object} obj The object that needs to be cloned.\n * @returns {Object} Copy.\n * @api private\n */\nPrimus.prototype.clone = function clone(obj) {\n  return this.merge({}, obj);\n};\n\n/**\n * Merge different objects in to one target object.\n *\n * @param {Object} target The object where everything should be merged in.\n * @returns {Object} Original target with all merged objects.\n * @api private\n */\nPrimus.prototype.merge = function merge(target) {\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  for (var i = 0, l = args.length, key, obj; i < l; i++) {\n    obj = args[i];\n\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) target[key] = obj[key];\n    }\n  }\n\n  return target;\n};\n\n/**\n * Parse the connection string.\n *\n * @type {Function}\n * @param {String} url Connection URL.\n * @returns {Object} Parsed connection.\n * @api private\n */\nPrimus.prototype.parse = parse;\n\n/**\n * Parse a query string.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object} Parsed query string.\n * @api private\n */\nPrimus.prototype.querystring = qs.parse;\n/**\n * Transform a query string object back into string equiv.\n *\n * @param {Object} obj The query string object.\n * @returns {String}\n * @api private\n */\nPrimus.prototype.querystringify = qs.stringify;\n\n/**\n * Generates a connection URI.\n *\n * @param {String} protocol The protocol that should used to crate the URI.\n * @returns {String|options} The URL.\n * @api private\n */\nPrimus.prototype.uri = function uri(options) {\n  var url = this.url\n    , server = []\n    , qsa = false;\n\n  //\n  // Query strings are only allowed when we've received clearance for it.\n  //\n  if (options.query) qsa = true;\n\n  options = options || {};\n  options.protocol = 'protocol' in options ? options.protocol : 'http';\n  options.query = url.search && 'query' in options ? (url.search.charAt(0) === '?' ? url.search.slice(1) : url.search) : false;\n  options.secure = 'secure' in options ? options.secure : (url.protocol === 'https:' || url.protocol === 'wss:');\n  options.auth = 'auth' in options ? options.auth : url.auth;\n  options.pathname = 'pathname' in options ? options.pathname : this.pathname.slice(1);\n  options.port = 'port' in options ? +options.port : +url.port || (options.secure ? 443 : 80);\n  options.host = 'host' in options ? options.host : url.hostname || url.host.replace(':'+ url.port, '');\n\n  //\n  // Allow transformation of the options before we construct a full URL from it.\n  //\n  this.emit('outgoing::url', options);\n\n  //\n  // `url.host` might be undefined (e.g. when using zombie) so we use the\n  // hostname and port defined above.\n  //\n  var host = (443 !== options.port && 80 !== options.port)\n    ? options.host +':'+ options.port\n    : options.host;\n\n  //\n  // We need to make sure that we create a unique connection URL every time to\n  // prevent back forward cache from becoming an issue. We're doing this by\n  // forcing an cache busting query string in to the URL.\n  //\n  var querystring = this.querystring(options.query || '');\n  querystring._primuscb = +new Date() +'-'+ this.stamps++;\n  options.query = this.querystringify(querystring);\n\n  //\n  // Automatically suffix the protocol so we can supply `ws` and `http` and it gets\n  // transformed correctly.\n  //\n  server.push(options.secure ? options.protocol +'s:' : options.protocol +':', '');\n\n  if (options.auth) server.push(options.auth +'@'+ host);\n  else server.push(host);\n\n  //\n  // Pathnames are optional as some Transformers would just use the pathname\n  // directly.\n  //\n  if (options.pathname) server.push(options.pathname);\n\n  //\n  // Optionally add a search query.\n  //\n  if (qsa) server.push('?'+ options.query);\n  else delete options.query;\n\n  if (options.object) return options;\n  return server.join('/');\n};\n\n/**\n * Register a new message transformer. This allows you to easily manipulate incoming\n * and outgoing data which is particularity handy for plugins that want to send\n * meta data together with the messages.\n *\n * @param {String} type Incoming or outgoing\n * @param {Function} fn A new message transformer.\n * @returns {Primus}\n * @api public\n */\nPrimus.prototype.transform = function transform(type, fn) {\n  context(this, 'transform');\n\n  if (!(type in this.transformers)) {\n    return this.critical(new Error('Invalid transformer type'));\n  }\n\n  this.transformers[type].push(fn);\n  return this;\n};\n\n/**\n * A critical error has occurred, if we have an `error` listener, emit it there.\n * If not, throw it, so we get a stack trace + proper error message.\n *\n * @param {Error} err The critical error.\n * @returns {Primus}\n * @api private\n */\nPrimus.prototype.critical = function critical(err) {\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n    return this;\n  }\n\n  throw err;\n};\n\n/**\n * Syntax sugar, adopt a Socket.IO like API.\n *\n * @param {String} url The URL we want to connect to.\n * @param {Object} options Connection options.\n * @returns {Primus}\n * @api public\n */\nPrimus.connect = function connect(url, options) {\n  return new Primus(url, options);\n};\n\n//\n// Expose the EventEmitter so it can be re-used by wrapping libraries we're also\n// exposing the Stream interface.\n//\nPrimus.EventEmitter = EventEmitter;\n\n//\n// These libraries are automatically are automatically inserted at the\n// server-side using the Primus#library method.\n//\nPrimus.prototype.client = function client() {\n  var primus = this\n    , socket;\n\n  //\n  // Select an available WebSocket factory.\n  //\n  var Factory = (function factory() {\n    if ('undefined' !== typeof WebSocket) return WebSocket;\n    if ('undefined' !== typeof MozWebSocket) return MozWebSocket;\n\n    try { return Primus.require('ws'); }\n    catch (e) {}\n\n    return undefined;\n  })();\n\n  if (!Factory) return primus.critical(new Error(\n    'Missing required `ws` module. Please run `npm install --save ws`'\n  ));\n\n\n  //\n  // Connect to the given URL.\n  //\n  primus.on('outgoing::open', function opening() {\n    primus.emit('outgoing::end');\n\n    //\n    // FireFox will throw an error when we try to establish a connection from\n    // a secure page to an unsecured WebSocket connection. This is inconsistent\n    // behaviour between different browsers. This should ideally be solved in\n    // Primus when we connect.\n    //\n    try {\n      var prot = primus.url.protocol === 'ws+unix:' ? 'ws+unix' : 'ws'\n        , qsa = prot === 'ws';\n\n      //\n      // Only allow primus.transport object in Node.js, it will throw in\n      // browsers with a TypeError if we supply to much arguments.\n      //\n      if (Factory.length === 3) {\n        primus.socket = socket = new Factory(\n          primus.uri({ protocol: prot, query: qsa }),   // URL\n          [],                                           // Sub protocols\n          primus.transport                              // options.\n        );\n      } else {\n        primus.socket = socket = new Factory(primus.uri({\n          protocol: prot,\n          query: qsa\n        }));\n      }\n    } catch (e) { return primus.emit('error', e); }\n\n    //\n    // Setup the Event handlers.\n    //\n    socket.binaryType = 'arraybuffer';\n    socket.onopen = primus.trigger('incoming::open');\n    socket.onerror = primus.trigger('incoming::error');\n    socket.onclose = primus.trigger('incoming::end');\n    socket.onmessage = primus.trigger('incoming::data', function parse(next, evt) {\n      setTimeout(function defer() {\n        next(undefined, evt.data);\n      }, 0);\n    });\n  });\n\n  //\n  // We need to write a new message to the socket.\n  //\n  primus.on('outgoing::data', function write(message) {\n    if (!socket || socket.readyState !== Factory.OPEN) return;\n\n    try { socket.send(message); }\n    catch (e) { primus.emit('incoming::error', e); }\n  });\n\n  //\n  // Attempt to reconnect the socket.\n  //\n  primus.on('outgoing::reconnect', function reconnect() {\n    primus.emit('outgoing::open');\n  });\n\n  //\n  // We need to close the socket.\n  //\n  primus.on('outgoing::end', function close() {\n    if (!socket) return;\n\n    socket.onerror = socket.onopen = socket.onclose = socket.onmessage = function () {};\n    socket.close();\n    socket = null;\n  });\n};\nPrimus.prototype.authorization = false;\nPrimus.prototype.pathname = \"/primus\";\nPrimus.prototype.encoder = function encoder(data, fn) {\n  var err;\n\n  try { data = JSON.stringify(data); }\n  catch (e) { err = e; }\n\n  fn(err, data);\n};\nPrimus.prototype.decoder = function decoder(data, fn) {\n  var err;\n\n  if ('string' !== typeof data) return fn(err, data);\n\n  try { data = JSON.parse(data); }\n  catch (e) { err = e; }\n\n  fn(err, data);\n};\nPrimus.prototype.version = \"3.0.2\";\n\n//\n// Hack 1: \\u2028 and \\u2029 are allowed inside string in JSON. But JavaScript\n// defines them as newline separators. Because no literal newlines are allowed\n// in a string this causes a ParseError. We work around this issue by replacing\n// these characters with a properly escaped version for those chars. This can\n// cause errors with JSONP requests or if the string is just evaluated.\n//\n// This could have been solved by replacing the data during the \"outgoing::data\"\n// event. But as it affects the JSON encoding in general I've opted for a global\n// patch instead so all JSON.stringify operations are save.\n//\nif (\n    'object' === typeof JSON\n && 'function' === typeof JSON.stringify\n && JSON.stringify(['\\u2028\\u2029']) === '[\"\\u2028\\u2029\"]'\n) {\n  JSON.stringify = function replace(stringify) {\n    var u2028 = /\\u2028/g\n      , u2029 = /\\u2029/g;\n\n    return function patched(value, replacer, spaces) {\n      var result = stringify.call(this, value, replacer, spaces);\n\n      //\n      // Replace the bad chars.\n      //\n      if (result) {\n        if (~result.indexOf('\\u2028')) result = result.replace(u2028, '\\\\u2028');\n        if (~result.indexOf('\\u2029')) result = result.replace(u2029, '\\\\u2029');\n      }\n\n      return result;\n    };\n  }(JSON.stringify);\n}\n\nif (\n     'undefined' !== typeof document\n  && 'undefined' !== typeof navigator\n) {\n  //\n  // Hack 2: If you press ESC in FireFox it will close all active connections.\n  // Normally this makes sense, when your page is still loading. But versions\n  // before FireFox 22 will close all connections including WebSocket connections\n  // after page load. One way to prevent this is to do a `preventDefault()` and\n  // cancel the operation before it bubbles up to the browsers default handler.\n  // It needs to be added as `keydown` event, if it's added keyup it will not be\n  // able to prevent the connection from being closed.\n  //\n  if (document.addEventListener) {\n    document.addEventListener('keydown', function keydown(e) {\n      if (e.keyCode !== 27 || !e.preventDefault) return;\n\n      e.preventDefault();\n    }, false);\n  }\n\n  //\n  // Hack 3: This is a Mac/Apple bug only, when you're behind a reverse proxy or\n  // have you network settings set to `automatic proxy discovery` the safari\n  // browser will crash when the WebSocket constructor is initialised. There is\n  // no way to detect the usage of these proxies available in JavaScript so we\n  // need to do some nasty browser sniffing. This only affects Safari versions\n  // lower then 5.1.4\n  //\n  var ua = (navigator.userAgent || '').toLowerCase()\n    , parsed = ua.match(/.+(?:rv|it|ra|ie)[\\/: ](\\d+)\\.(\\d+)(?:\\.(\\d+))?/) || []\n    , version = +[parsed[1], parsed[2]].join('.');\n\n  if (\n       !~ua.indexOf('chrome')\n    && ~ua.indexOf('safari')\n    && version < 534.54\n  ) {\n    Primus.prototype.AVOID_WEBSOCKETS = true;\n  }\n}\n\n//\n// Expose the library.\n//\nmodule.exports = Primus;\n\n},{\"demolish\":1,\"emits\":2,\"eventemitter3\":3,\"querystringify\":4,\"recovery\":5,\"tick-tock\":8}]},{},[10])(10);\n  return Primus;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/js/vendor/primus.js\n ** module id = 1\n ** module chunks = 1\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/main.js\n ** module id = 2\n ** module chunks = 1\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/~/process/browser.js\n ** module id = 3\n ** module chunks = 1\n **/"],"sourceRoot":""}